// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package model

import (
	"fmt"
	"io"
	"strconv"
)

type Pageable interface {
	IsPageable()
}

type ApplicationSettings struct {
	AllowPublicLinkCreation bool `json:"allowPublicLinkCreation"`
}

type EditGroup struct {
	ID     int    `json:"id"`
	Public bool   `json:"public"`
	Owner  string `json:"owner"`
}

type EditJump struct {
	ID       int      `json:"id"`
	Name     string   `json:"name"`
	Location string   `json:"location"`
	Alias    []string `json:"alias"`
}

type Mutation struct {
}

type NewGroup struct {
	Name   string `json:"name"`
	Public bool   `json:"public"`
}

type NewJump struct {
	Name     string   `json:"name"`
	Location string   `json:"location"`
	Alias    []string `json:"alias"`
	Group    int      `json:"group"`
}

type Page struct {
	Results []Pageable `json:"results"`
	Count   int        `json:"count"`
	More    bool       `json:"more"`
}

type Query struct {
}

type ResourceOwner struct {
	User  string `json:"user"`
	Group string `json:"group"`
}

type Subscription struct {
}

type User struct {
	ID       string   `json:"id"`
	Subject  string   `json:"subject"`
	Username string   `json:"username"`
	Email    string   `json:"email"`
	Admin    bool     `json:"admin"`
	Groups   []string `json:"groups"`
}

func (User) IsPageable() {}

type Verb string

const (
	VerbCreate Verb = "CREATE"
	VerbRead   Verb = "READ"
	VerbUpdate Verb = "UPDATE"
	VerbDelete Verb = "DELETE"
	VerbSudo   Verb = "SUDO"
)

var AllVerb = []Verb{
	VerbCreate,
	VerbRead,
	VerbUpdate,
	VerbDelete,
	VerbSudo,
}

func (e Verb) IsValid() bool {
	switch e {
	case VerbCreate, VerbRead, VerbUpdate, VerbDelete, VerbSudo:
		return true
	}
	return false
}

func (e Verb) String() string {
	return string(e)
}

func (e *Verb) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = Verb(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid Verb", str)
	}
	return nil
}

func (e Verb) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}
