package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.45

import (
	"context"
	"fmt"
	"slices"
	"strconv"
	"strings"

	"github.com/Snakdy/go-rbac-proxy/pkg/rbac"
	"github.com/go-logr/logr"
	"gitlab.dcas.dev/jmp/go-jmp/internal/identity"
	"gitlab.dcas.dev/jmp/go-jmp/internal/ql/graph/generated"
	"gitlab.dcas.dev/jmp/go-jmp/internal/ql/graph/model"
	"gitlab.dcas.dev/jmp/go-jmp/pkg/api"
	"gitlab.dcas.dev/jmp/go-jmp/pkg/dao"
	"gitlab.dcas.dev/jmp/go-jmp/pkg/schemas"
)

// ID is the resolver for the id field.
func (r *groupResolver) ID(ctx context.Context, obj *model.Group) (string, error) {
	return strconv.Itoa(int(obj.ID)), nil
}

// Users is the resolver for the users field.
func (r *groupResolver) Users(ctx context.Context, obj *model.Group) ([]string, error) {
	if obj.Users == "" {
		return nil, nil
	}
	rawUsers := strings.Split(obj.Users, ",")
	var users []string
	for i := range rawUsers {
		u := strings.TrimSpace(rawUsers[i])
		if u == "" {
			continue
		}
		users = append(users, u)
	}
	return users, nil
}

// ID is the resolver for the id field.
func (r *jumpResolver) ID(ctx context.Context, obj *model.Jump) (string, error) {
	return strconv.Itoa(int(obj.ID)), nil
}

// Owner is the resolver for the owner field.
func (r *jumpResolver) Owner(ctx context.Context, obj *model.Jump) (*model.ResourceOwner, error) {
	resourceType, resourceId, _ := strings.Cut(obj.Owner, "://")
	resource := &model.ResourceOwner{}
	switch resourceType {
	case "user":
		resource.User = resourceId
	case "group":
		groupId, err := strconv.ParseInt(resourceId, 10, 64)
		if err != nil {
			return nil, fmt.Errorf("parsing group id: %w", err)
		}
		group, err := r.repos.GroupRepo.FindByID(ctx, int(groupId))
		if err != nil {
			return nil, fmt.Errorf("finding group: %w", err)
		}
		resource.Group = group.Name
	}
	return resource, nil
}

// Alias is the resolver for the alias field.
func (r *jumpResolver) Alias(ctx context.Context, obj *model.Jump) ([]string, error) {
	return obj.Alias, nil
}

// ID is the resolver for the id field.
func (r *jumpEventResolver) ID(ctx context.Context, obj *model.JumpEvent) (string, error) {
	return strconv.Itoa(int(obj.ID)), nil
}

// JumpID is the resolver for the jumpID field.
func (r *jumpEventResolver) JumpID(ctx context.Context, obj *model.JumpEvent) (string, error) {
	return strconv.Itoa(int(obj.JumpID)), nil
}

// CreateJump is the resolver for the createJump field.
func (r *mutationResolver) CreateJump(ctx context.Context, input model.NewJump) (*model.Jump, error) {
	if _, ok := identity.GetContextUser(ctx); !ok {
		return nil, ErrUnauthorised
	}
	return r.jumpService.Create(ctx, api.CreateJumpOpts{
		GID:      input.Group,
		Name:     input.Name,
		Location: input.Location,
		Alias:    input.Alias,
	})
}

// PatchJump is the resolver for the patchJump field.
func (r *mutationResolver) PatchJump(ctx context.Context, input model.EditJump) (*model.Jump, error) {
	if err := r.CanI(ctx, schemas.ResourceName(schemas.ResourceJump, input.ID), rbac.Verb_UPDATE); err != nil {
		return nil, err
	}
	return r.jumpService.Update(ctx, api.UpdateJumpOpts{
		ID:       input.ID,
		Name:     input.Name,
		Location: input.Location,
		Alias:    input.Alias,
	})
}

// DeleteJump is the resolver for the deleteJump field.
func (r *mutationResolver) DeleteJump(ctx context.Context, id int) (bool, error) {
	if err := r.CanI(ctx, schemas.ResourceName(schemas.ResourceJump, id), rbac.Verb_DELETE); err != nil {
		return false, err
	}
	return r.jumpService.Delete(ctx, id)
}

// CreateGroup is the resolver for the createGroup field.
func (r *mutationResolver) CreateGroup(ctx context.Context, input model.NewGroup) (*model.Group, error) {
	if _, ok := identity.GetContextUser(ctx); !ok {
		return nil, ErrUnauthorised
	}
	return r.groupService.Create(ctx, input.Name, input.Public, false)
}

// PatchGroup is the resolver for the patchGroup field.
func (r *mutationResolver) PatchGroup(ctx context.Context, input model.EditGroup) (*model.Group, error) {
	if err := r.CanI(ctx, schemas.ResourceName(schemas.ResourceGroup, input.ID), rbac.Verb_UPDATE); err != nil {
		return nil, err
	}
	return r.groupService.Patch(ctx, input)
}

// CurrentUser is the resolver for the currentUser field.
func (r *queryResolver) CurrentUser(ctx context.Context) (*model.User, error) {
	log := logr.FromContextOrDiscard(ctx)
	user, ok := identity.GetContextUser(ctx)
	if !ok {
		return nil, ErrUnauthorised
	}
	userDao, err := r.userService.CreateOrUpdateUser(ctx, user)
	if err != nil {
		return nil, err
	}
	var isAdmin bool
	resp, err := r.authz.Can(ctx, &rbac.AccessRequest{
		Subject:  user.Subject,
		Resource: "SUPER",
		Action:   rbac.Verb_SUDO,
	})
	if err != nil {
		log.Error(err, "failed to verify user privilege")
	} else {
		isAdmin = resp.GetOk()
	}
	var groups []string
	if userDao.Groups != "" {
		groups = strings.Split(userDao.Groups, ",")
	}
	var filteredGroups []string
	for i := range groups {
		g := strings.TrimSpace(groups[i])
		if g == "" {
			continue
		}
		// try to create the group but
		// swallow any errors since we don't really care
		// if it fails
		_, _ = r.groupService.Create(ctx, g, false, true)
		filteredGroups = append(filteredGroups, g)
	}
	log.V(2).Info("loaded user groups", "groups", filteredGroups)
	if slices.ContainsFunc(filteredGroups, func(s string) bool {
		return slices.Contains(r.adminGroups, s)
	}) {
		isAdmin = true
	}

	return &model.User{
		ID:       strconv.Itoa(int(userDao.ID)),
		Subject:  userDao.Subject,
		Username: userDao.Username,
		Email:    userDao.Email,
		Admin:    isAdmin,
		Groups:   filteredGroups,
	}, err
}

// JumpTo is the resolver for the jumpTo field.
func (r *queryResolver) JumpTo(ctx context.Context, target int) (*model.Jump, error) {
	return r.jumpService.JumpTo(ctx, target)
}

// SearchJumps is the resolver for the searchJumps field.
func (r *queryResolver) SearchJumps(ctx context.Context, offset int, limit int, target string) (*model.Page, error) {
	return r.jumpService.Search(ctx, offset, limit, -1, target)
}

// Jumps is the resolver for the jumps field.
func (r *queryResolver) Jumps(ctx context.Context, offset int, limit int) (*model.Page, error) {
	return r.jumpService.List(ctx, offset, limit)
}

// Users is the resolver for the users field.
func (r *queryResolver) Users(ctx context.Context, offset int, limit int) (*model.Page, error) {
	if _, ok := identity.GetContextUser(ctx); !ok {
		return nil, ErrUnauthorised
	}
	return r.repos.UserRepo.GetUsers(ctx, offset, limit)
}

// Groups is the resolver for the groups field.
func (r *queryResolver) Groups(ctx context.Context, offset int, limit int) (*model.Page, error) {
	user, ok := identity.GetContextUser(ctx)
	if !ok {
		return nil, ErrUnauthorised
	}
	return r.repos.GroupRepo.GetGroups(ctx, user.Subject, offset, limit)
}

// GroupsForUser is the resolver for the groupsForUser field.
func (r *queryResolver) GroupsForUser(ctx context.Context, username string) ([]*model.Group, error) {
	_, ok := identity.GetContextUser(ctx)
	if !ok {
		return nil, ErrUnauthorised
	}
	return r.repos.GroupRepo.GetUserGroups(ctx, username)
}

// TopPicks is the resolver for the topPicks field.
func (r *queryResolver) TopPicks(ctx context.Context, amount int) ([]*model.Jump, error) {
	if _, ok := identity.GetContextUser(ctx); !ok {
		return nil, ErrUnauthorised
	}
	return r.jumpEventService.GetTopPicks(ctx, amount)
}

// Similar is the resolver for the similar field.
func (r *queryResolver) Similar(ctx context.Context, query string) ([]*model.Jump, error) {
	results, err := r.jumpService.Search(ctx, 0, 5, 0, query)
	if err != nil {
		return nil, err
	}

	// convert the results back
	jumps := make([]*model.Jump, len(results.Results))
	for i := range results.Results {
		// cast is good
		jumps[i] = (results.Results[i]).(*model.Jump)
	}

	return jumps, nil
}

// AuthCanI is the resolver for the authCanI field.
func (r *queryResolver) AuthCanI(ctx context.Context, resource string, action model.Verb) (bool, error) {
	if err := r.CanI(ctx, resource, action.DAO()); err != nil {
		return false, err
	}
	return true, nil
}

// ApplicationSettings is the resolver for the applicationSettings field.
func (r *queryResolver) ApplicationSettings(ctx context.Context) (*model.ApplicationSettings, error) {
	return r.applicationSettings, nil
}

// Jumps is the resolver for the jumps field.
func (r *subscriptionResolver) Jumps(ctx context.Context, offset int, limit int, target string) (<-chan *model.Page, error) {
	return r.streamPage(ctx, r.jumpService.ListeningService, func(message *dao.Message) (*model.Page, error) {
		// if we're given a query, search for that
		if target != "" {
			return r.jumpService.Search(ctx, offset, limit, -1, target)
		}
		// otherwise, list everything
		return r.jumpService.List(ctx, offset, limit)
	}), nil
}

// Users is the resolver for the users field.
func (r *subscriptionResolver) Users(ctx context.Context, offset int, limit int, target string) (<-chan *model.Page, error) {
	if _, ok := identity.GetContextUser(ctx); !ok {
		return nil, ErrUnauthorised
	}
	return r.streamPage(ctx, r.userService.ListeningService, func(message *dao.Message) (*model.Page, error) {
		return r.repos.UserRepo.GetUsers(ctx, offset, limit)
	}), nil
}

// Groups is the resolver for the groups field.
func (r *subscriptionResolver) Groups(ctx context.Context, offset int, limit int, target string) (<-chan *model.Page, error) {
	user, ok := identity.GetContextUser(ctx)
	if !ok {
		return nil, ErrUnauthorised
	}
	return r.streamPage(ctx, r.groupService.ListeningService, func(message *dao.Message) (*model.Page, error) {
		return r.repos.GroupRepo.GetGroups(ctx, user.Subject, offset, limit)
	}), nil
}

// Group returns generated.GroupResolver implementation.
func (r *Resolver) Group() generated.GroupResolver { return &groupResolver{r} }

// Jump returns generated.JumpResolver implementation.
func (r *Resolver) Jump() generated.JumpResolver { return &jumpResolver{r} }

// JumpEvent returns generated.JumpEventResolver implementation.
func (r *Resolver) JumpEvent() generated.JumpEventResolver { return &jumpEventResolver{r} }

// Mutation returns generated.MutationResolver implementation.
func (r *Resolver) Mutation() generated.MutationResolver { return &mutationResolver{r} }

// Query returns generated.QueryResolver implementation.
func (r *Resolver) Query() generated.QueryResolver { return &queryResolver{r} }

// Subscription returns generated.SubscriptionResolver implementation.
func (r *Resolver) Subscription() generated.SubscriptionResolver { return &subscriptionResolver{r} }

type groupResolver struct{ *Resolver }
type jumpResolver struct{ *Resolver }
type jumpEventResolver struct{ *Resolver }
type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type subscriptionResolver struct{ *Resolver }
